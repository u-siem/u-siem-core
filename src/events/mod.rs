use crate::prelude::types::LogString;
use serde::{Deserialize, Serialize};
use std::collections::{BTreeMap, BTreeSet};
pub mod auth;
pub mod common;
pub mod dhcp;
pub mod dns;
pub mod field;
pub mod field_dictionary;
pub mod firewall;
pub mod intrusion;
pub mod protocol;
pub mod schema;
pub mod tags;
pub mod webproxy;
pub mod webserver;
//use serde::ser::{Serializer, SerializeStruct};
use auth::{AuthEvent, AuthLoginType};
use dhcp::{DhcpEvent, DhcpRecordType};
use dns::{DnsEvent, DnsEventType};
use field::{SiemField, SiemIp};
use firewall::FirewallEvent;
use intrusion::IntrusionEvent;
use webproxy::WebProxyEvent;
use webserver::WebServerEvent;

#[derive(Serialize, Deserialize, Debug, Clone, Default)]
#[serde(tag = "event_type")]
pub enum SiemEvent {
    /// Firewall events: connections between IPs, blocked connections...
    Firewall(FirewallEvent),
    /// Intrusion detection/protection systems. Ex: Suricata, Snort, OSSEC, Wazuh, NGFW...
    Intrusion(IntrusionEvent),
    /// Security related assessment, like the output of vulnerability scanners (Nessus) or policy enforcers (OpenSCAP). PulseSecure and Forescout can also get in this category.
    Assessment,
    /// Web Browsing Proxy
    WebProxy(WebProxyEvent),
    /// Web application servers, Adaptative Distribution Content or LoadBalancers for HTTP traffic.
    ///
    ///
    /// Ex: Apache, Nginx, Tomact or IIS.
    WebServer(WebServerEvent),
    /// Like an antivirus, a Sandbox retrieves information about a file being malicious or not. Can be used
    /// to extract filenames, hashes or other relevant information to update a dataset of known hashes and
    /// trigger queries.
    ///
    ///  Ex: Wildfire, Mcafee ATD, Cuckoo...
    Sandbox,
    Antivirus,
    /// Data Loss Prevention are devices that detect anomalous behavour related to
    /// data exfiltration.
    ///
    /// Ex: Boldon
    DLP,
    /// Some devices like email gateways generates a large number of logs when an email arrives: Header processing, AV scan, attachment information...
    /// In those cases, each log is associated with an action using a trace ID or a transaction ID.
    Partitioned,
    /// Endpoint Detection and Response devices, also EPP.
    EDR,
    /// Mail events, as the name suggest are events generated by an email gateway. Can
    /// contain threat related information if an anomaly was detected.
    /// Note that some devices generate partitioned logs instead of Mail logs.
    ///
    /// Ex: Microsoft Exchange, IronPort, Office 365...
    Mail,
    /// DNS requests events. To better correlate this type of events, be carefull of checking if it contains a dns_server
    /// tag, because that means that the originator of the request is a Recursive DNS and not an endpoint. It normally
    /// happens if the one generating the log was a firewall (Ex: Palo Alto) and not a DNS server, or if multiple DNS are
    /// used in the organization, like a DNS talking to another DNS.
    DNS(DnsEvent),
    /// DHCP logs associating an IP with a MAC address.
    DHCP(DhcpEvent),
    /// Logs related to authentication, like a user trying to log in to a Router,
    /// a server or any kind of system.
    ///
    /// Ex: RDP, Windows, Linux, Mailbox login...
    Auth(AuthEvent),
    /// Local events related to servers or workstations, like OS failed to update,
    /// antivirus outdated, log file cleaned, user or group changes (Including global or universal domain events).
    /// Also events related to network devices: Changes in routing policys, Firewall rules, Shutdown out of mantaince
    Endpoint,
    // Unknown info that must be extracted and added to event fields. JSON format, like Windows events
    Json(serde_json::Value),
    // Unknown info that must be extracted and added to event fields.
    #[default]
    Unknown,
    /// Forensic artifacts from custom parsers
    Artifacts,
}

/// This is a simple log event. It contains information about the asset that generated
/// this log, the client if we are working in a multi-client environments aka SOC,
/// some fields to facilitate correlation with SIGMA rules, timestamps and tags to
/// better describe the content inside.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SiemLog {
    #[serde(skip, default)]
    /// IP or Hostname of the server that sent the log.
    origin: LogString,
    #[serde(skip, default)]
    /// Customer name for SOC environments. Ex: Contoso
    tenant: LogString,
    #[serde(skip, default)]
    /// Name of the product for wich the log belongs. Ex: ASA
    product: LogString,
    #[serde(skip, default)]
    /// Subset of the product logs. Like a OS that can have multiple programs running inside generating multiple logs.
    service: LogString,
    #[serde(skip, default)]
    /// Category of the device: Firewall, web, antivirus
    category: LogString,
    #[serde(skip, default)]
    /// Company that created the product. Ex: Cisco
    vendor: LogString,
    #[serde(skip, default)]
    /// Categorization of the log. This forces the developer to use
    /// the same naming convention and reduces the number of human errors.
    event: SiemEvent,
    /// Tags to better describe the event.Must be in lowercase. Ex: vip_user, critical_asset, fake_account, honeypot
    tags: BTreeSet<LogString>,
    /// Map of fields extracted or generated for this log. Must follow the Elastic Common Schema (ECS v1.x)
    #[serde(flatten)]
    fields: BTreeMap<LogString, SiemField>,
    #[serde(skip, default)]
    /// Original log message including syslog header
    message: String,
    #[serde(skip, default)]
    /// Timestamp at witch the log arrived  
    event_received: i64,
    #[serde(skip, default)]
    /// Timestamp at witch the log was generated. The clocks at origin must be correctly configured.
    event_created: i64,
    #[serde(skip, default)]
    ip_fields: BTreeSet<LogString>,
}

impl<'a> SiemLog {
    pub fn new<S, M>(message: M, received: i64, origin: S) -> SiemLog
    where
        S: Into<LogString>,
        M: Into<String>,
    {
        let cw = origin.into();
        let ms = message.into();
        let mut fields = BTreeMap::new();
        fields.insert(
            LogString::Borrowed("message"),
            SiemField::Text(LogString::Owned(ms.to_string())),
        );
        fields.insert(
            LogString::Borrowed("origin"),
            SiemField::Text(LogString::Owned(cw.to_string())),
        );
        fields.insert(
            LogString::Borrowed("event_created"),
            SiemField::Date(received),
        );
        fields.insert(
            LogString::Borrowed("event_received"),
            SiemField::Date(received),
        );
        SiemLog {
            message: ms,
            event_received: received,
            origin: cw,
            tenant: LogString::default(),
            product: LogString::default(),
            service: LogString::default(),
            category: LogString::default(),
            vendor: LogString::default(),
            event: SiemEvent::Unknown,
            tags: BTreeSet::default(),
            fields,
            event_created: received,
            ip_fields: BTreeSet::new(),
        }
    }

    pub fn message(&'a self) -> &'a str {
        &self.message
    }
    pub fn origin(&'a self) -> &'a str {
        &self.origin
    }
    pub fn tenant(&'a self) -> &'a str {
        &self.tenant
    }
    pub fn set_tenant<S>(&mut self, tenant: S)
    where
        S: Into<LogString>,
    {
        let tenant = tenant.into();
        self.fields.insert(
            LogString::Borrowed("tenant"),
            SiemField::Text(tenant.clone()),
        );
        self.tenant = tenant;
    }
    pub fn product(&'a self) -> &'a str {
        &self.product
    }
    pub fn set_product<S>(&mut self, product: S)
    where
        S: Into<LogString>,
    {
        let product = product.into();
        self.fields.insert(
            LogString::Borrowed("product"),
            SiemField::Text(product.clone()),
        );
        self.product = product;
    }
    pub fn service(&'a self) -> &'a str {
        &self.service
    }

    pub fn set_service<S>(&mut self, service: S)
    where
        S: Into<LogString>,
    {
        let service = service.into();
        self.fields.insert(
            LogString::Borrowed("service"),
            SiemField::Text(service.clone()),
        );
        self.service = service;
    }
    pub fn category(&'a self) -> &'a str {
        &self.category
    }
    pub fn set_category<S>(&mut self, category: S)
    where
        S: Into<LogString>,
    {
        let category = category.into();
        self.fields.insert(
            LogString::Borrowed("category"),
            SiemField::Text(category.clone()),
        );
        self.category = category;
    }
    pub fn vendor(&'a self) -> &'a str {
        &self.vendor
    }
    pub fn set_vendor<S>(&mut self, vendor: S)
    where
        S: Into<LogString>,
    {
        let vendor = vendor.into();
        self.fields.insert(
            LogString::Borrowed("vendor"),
            SiemField::Text(vendor.clone()),
        );
        self.vendor = vendor;
    }
    pub fn event_received(&'a self) -> i64 {
        self.event_received
    }
    pub fn event_created(&'a self) -> i64 {
        self.event_created
    }
    pub fn set_event_created(&mut self, date: i64) {
        self.event_created = date;
        self.fields
            .insert(LogString::Borrowed("event_created"), SiemField::I64(date));
    }
    pub fn has_tag(&self, tag: &str) -> bool {
        self.tags.contains(tag)
    }
    pub fn add_tag(&mut self, tag: &str) {
        self.tags.insert(LogString::Owned(tag.to_lowercase()));
        self.fields.insert(
            LogString::Borrowed("tags"),
            SiemField::Text(LogString::Owned(
                self.tags
                    .iter()
                    .map(|x| x.to_uppercase())
                    .collect::<Vec<String>>()
                    .join(","),
            )),
        );
    }
    pub fn tags(&'a self) -> &'a BTreeSet<LogString> {
        &self.tags
    }
    pub fn field(&'a self, field_name: &str) -> Option<&SiemField> {
        self.fields.get(field_name)
    }
    pub fn field_mut(&'a mut self, field_name: &str) -> Option<&mut SiemField> {
        self.fields.get_mut(field_name)
    }
    pub fn add_field(&mut self, field_name: &str, field_value: SiemField) {
        let field_name = LogString::Owned(field_name.to_owned());
        self.insert(field_name, field_value);
    }
    pub fn insert(&mut self, field_name: LogString, field_value: SiemField) {
        if let SiemField::IP(_) = &field_value {
            self.ip_fields.insert(field_name.clone());
        }
        self.fields.insert(field_name, field_value);
    }
    pub fn has_field(&self, field_name: &str) -> bool {
        self.fields.contains_key(field_name)
    }

    pub fn event(&self) -> &SiemEvent {
        &self.event
    }
    pub fn set_event(&mut self, event: SiemEvent) {
        match &event {
            SiemEvent::Firewall(fw) => {
                self.add_field(
                    field_dictionary::SOURCE_IP,
                    SiemField::IP(fw.source_ip().clone()),
                );
                self.add_field(
                    field_dictionary::DESTINATION_IP,
                    SiemField::IP(fw.destination_ip().clone()),
                );
                self.add_field(
                    field_dictionary::SOURCE_PORT,
                    SiemField::U32(fw.source_port as u32),
                );
                self.add_field(
                    field_dictionary::DESTINATION_PORT,
                    SiemField::U32(fw.destination_port as u32),
                );
                self.add_field(
                    field_dictionary::EVENT_OUTCOME,
                    SiemField::Text(LogString::Owned(fw.outcome().to_string())),
                );
                self.add_field(
                    field_dictionary::IN_INTERFACE,
                    SiemField::Text(LogString::Owned(fw.in_interface().to_string())),
                );
                self.add_field(
                    field_dictionary::OUT_INTERFACE,
                    SiemField::Text(LogString::Owned(fw.out_interface().to_string())),
                );
                self.add_field(field_dictionary::SOURCE_BYTES, SiemField::U32(fw.out_bytes));
                self.add_field(
                    field_dictionary::DESTINATION_BYTES,
                    SiemField::U32(fw.in_bytes),
                );
                self.add_field(
                    field_dictionary::NETWORK_TRANSPORT,
                    SiemField::Text(LogString::Owned(fw.network_protocol().to_string())),
                );
            }
            SiemEvent::WebProxy(fw) => {
                self.add_field(
                    field_dictionary::SOURCE_IP,
                    SiemField::IP(fw.source_ip().clone()),
                );
                self.add_field(
                    field_dictionary::DESTINATION_IP,
                    SiemField::IP(fw.destination_ip().clone()),
                );
                self.add_field(
                    field_dictionary::DESTINATION_PORT,
                    SiemField::U32(fw.destination_port as u32),
                );
                self.add_field(
                    field_dictionary::EVENT_OUTCOME,
                    SiemField::Text(LogString::Owned(fw.outcome().to_string())),
                );
                self.add_field(field_dictionary::SOURCE_BYTES, SiemField::U32(fw.out_bytes));
                self.add_field(
                    field_dictionary::DESTINATION_BYTES,
                    SiemField::U32(fw.in_bytes),
                );
                self.add_field(
                    field_dictionary::NETWORK_PROTOCOL,
                    SiemField::Text(LogString::Owned(fw.protocol().to_string())),
                );
                self.add_field(
                    field_dictionary::HTTP_RESPONSE_STATUS_CODE,
                    SiemField::U32(fw.http_code),
                );
                self.add_field(
                    field_dictionary::HTTP_REQUEST_METHOD,
                    SiemField::Text(LogString::Owned(fw.http_method().to_string())),
                );
                self.add_field(
                    field_dictionary::URL_FULL,
                    SiemField::Text(LogString::Owned(fw.url().to_string())),
                );
                self.add_field(
                    field_dictionary::URL_DOMAIN,
                    SiemField::Text(LogString::Owned(fw.domain().to_string())),
                );
                self.add_field(
                    field_dictionary::USER_NAME,
                    SiemField::User(fw.user_name().to_string()),
                );
                self.add_field(
                    field_dictionary::HTTP_RESPONSE_MIME_TYPE,
                    SiemField::from_str(fw.mime_type().to_string()),
                );
                match fw.rule_category() {
                    Some(rule_category) => {
                        self.add_field(
                            field_dictionary::RULE_CATEGORY,
                            SiemField::from_str(rule_category.to_string()),
                        );
                    }
                    None => {}
                }
                match fw.rule_name() {
                    Some(rule_name) => {
                        self.add_field(
                            field_dictionary::RULE_NAME,
                            SiemField::from_str(rule_name.to_string()),
                        );
                    }
                    None => {}
                }
            }
            SiemEvent::DNS(fw) => {
                self.add_field(
                    field_dictionary::SOURCE_IP,
                    SiemField::IP(fw.source_ip().clone()),
                );
                self.add_field(
                    field_dictionary::DESTINATION_IP,
                    SiemField::IP(fw.destination_ip().clone()),
                );
                match fw.op_code() {
                    DnsEventType::ANSWER => {
                        self.add_field(
                            field_dictionary::DNS_OP_CODE,
                            SiemField::Text(LogString::Borrowed("ANSWER")),
                        );
                        self.add_field(
                            field_dictionary::DNS_ANSWER_NAME,
                            SiemField::from_str(fw.record_name().to_string()),
                        );
                        match fw.data() {
                            Some(data) => {
                                self.add_field(
                                    field_dictionary::DNS_ANSWER_DATA,
                                    SiemField::from_str(data.to_string()),
                                );
                            }
                            None => {}
                        };
                        self.add_field(
                            field_dictionary::DNS_ANSWER_TYPE,
                            SiemField::Text(fw.record_type().as_cow()),
                        );
                    }
                    DnsEventType::QUERY => {
                        self.add_field(
                            field_dictionary::DNS_OP_CODE,
                            SiemField::Text(LogString::Borrowed("QUERY")),
                        );
                        self.add_field(
                            field_dictionary::DNS_QUESTION_NAME,
                            SiemField::from_str(fw.record_name().to_string()),
                        );
                        self.add_field(
                            field_dictionary::DNS_QUESTION_TYPE,
                            SiemField::Text(fw.record_type().as_cow()),
                        );
                    }
                };
            }
            SiemEvent::Intrusion(fw) => {
                self.add_field(
                    field_dictionary::SOURCE_IP,
                    SiemField::IP(fw.source_ip().clone()),
                );
                self.add_field(
                    field_dictionary::SOURCE_PORT,
                    SiemField::U32(fw.source_port as u32),
                );
                self.add_field(
                    field_dictionary::DESTINATION_IP,
                    SiemField::IP(fw.destination_ip().clone()),
                );
                self.add_field(
                    field_dictionary::DESTINATION_PORT,
                    SiemField::U32(fw.destination_port as u32),
                );
                self.add_field(
                    field_dictionary::EVENT_OUTCOME,
                    SiemField::Text(LogString::Owned(fw.outcome().to_string())),
                );
                self.add_field(
                    field_dictionary::NETWORK_PROTOCOL,
                    SiemField::Text(LogString::Owned(fw.network_protocol().to_string())),
                );
                self.add_field(
                    field_dictionary::RULE_CATEGORY,
                    SiemField::from_str(fw.rule_category().to_string()),
                );
                self.add_field(
                    field_dictionary::RULE_NAME,
                    SiemField::from_str(fw.rule_name().to_string()),
                );
                self.add_field(field_dictionary::RULE_ID, SiemField::U32(fw.rule_id));
            }
            SiemEvent::WebServer(fw) => {
                self.add_field(
                    field_dictionary::SOURCE_IP,
                    SiemField::IP(fw.source_ip().clone()),
                );
                match fw.destination_ip() {
                    Some(ip) => {
                        self.add_field(field_dictionary::DESTINATION_IP, SiemField::IP(ip.clone()));
                    }
                    None => {}
                };

                self.add_field(
                    field_dictionary::DESTINATION_PORT,
                    SiemField::U32(fw.destination_port as u32),
                );
                self.add_field(
                    field_dictionary::EVENT_OUTCOME,
                    SiemField::Text(LogString::Owned(fw.outcome().to_string())),
                );
                self.add_field(field_dictionary::SOURCE_BYTES, SiemField::U32(fw.out_bytes));
                self.add_field(
                    field_dictionary::DESTINATION_BYTES,
                    SiemField::U32(fw.in_bytes),
                );
                self.add_field(
                    field_dictionary::NETWORK_PROTOCOL,
                    SiemField::Text(LogString::Owned(fw.protocol().to_string())),
                );
                self.add_field(
                    field_dictionary::HTTP_RESPONSE_STATUS_CODE,
                    SiemField::U32(fw.http_code),
                );
                self.add_field(
                    field_dictionary::HTTP_REQUEST_METHOD,
                    SiemField::Text(LogString::Owned(fw.http_method().to_string())),
                );
                self.add_field(
                    field_dictionary::URL_FULL,
                    SiemField::Text(LogString::Owned(fw.url_full().to_string())),
                );
                self.add_field(
                    field_dictionary::URL_DOMAIN,
                    SiemField::Text(LogString::Owned(fw.url_domain().to_string())),
                );
                self.add_field(
                    field_dictionary::URL_PATH,
                    SiemField::Text(LogString::Owned(fw.url_path().to_string())),
                );
                self.add_field(
                    field_dictionary::URL_QUERY,
                    SiemField::Text(LogString::Owned(fw.url_query().to_string())),
                );
                self.add_field(
                    "url.extension",
                    SiemField::Text(LogString::Owned(fw.url_extension().to_string())),
                );
                self.add_field(
                    field_dictionary::USER_NAME,
                    SiemField::User(fw.user_name().to_string()),
                );
                self.add_field(
                    field_dictionary::HTTP_RESPONSE_MIME_TYPE,
                    SiemField::from_str(fw.mime_type().to_string()),
                );
                self.add_field(
                    field_dictionary::NETWORK_DURATION,
                    SiemField::F64(fw.duration as f64),
                );
                self.add_field(
                    "user_agent.original",
                    SiemField::Text(LogString::Owned(fw.user_agent().to_string())),
                );
            }
            SiemEvent::Auth(fw) => {
                self.add_field(
                    "host.hostname",
                    SiemField::Text(LogString::Owned(fw.hostname().to_string())),
                );
                self.add_field(
                    field_dictionary::EVENT_OUTCOME,
                    SiemField::Text(LogString::Owned(fw.outcome().to_string())),
                );
                match fw.login_type() {
                    AuthLoginType::Local(evnt) => {
                        self.add_field(
                            field_dictionary::USER_NAME,
                            SiemField::User(evnt.user_name.to_string()),
                        );
                        self.add_field(
                            field_dictionary::USER_DOMAIN,
                            SiemField::Domain(evnt.domain.to_string()),
                        );
                    }
                    AuthLoginType::Remote(evnt) => {
                        self.add_field(
                            field_dictionary::USER_NAME,
                            SiemField::User(evnt.user_name.to_string()),
                        );
                        self.add_field(
                            field_dictionary::USER_DOMAIN,
                            SiemField::Domain(evnt.domain.to_string()),
                        );
                        self.add_field(
                            "source.address",
                            SiemField::Text(LogString::Owned(evnt.source_address.to_string())),
                        );
                        match SiemIp::from_ip_str(&evnt.source_address) {
                            Ok(ip) => {
                                self.add_field("source.ip", SiemField::IP(ip));
                            }
                            Err(_) => {}
                        };
                    }
                    AuthLoginType::Upgrade(evnt) => {
                        self.add_field(
                            field_dictionary::USER_NAME,
                            SiemField::User(evnt.destination_user.to_string()),
                        );
                        self.add_field(
                            "source.user.name",
                            SiemField::User(evnt.source_user.to_string()),
                        );
                        self.add_field(
                            field_dictionary::USER_DOMAIN,
                            SiemField::Domain(evnt.destination_domain.to_string()),
                        );
                    }
                    AuthLoginType::Validation(evnt) => {
                        self.add_field(
                            field_dictionary::USER_NAME,
                            SiemField::User(evnt.user_name.to_string()),
                        );
                        self.add_field(
                            "source.address",
                            SiemField::Text(LogString::Owned(evnt.source_address.to_string())),
                        );
                        match SiemIp::from_ip_str(&evnt.source_address) {
                            Ok(ip) => {
                                self.add_field("source.ip", SiemField::IP(ip));
                            }
                            Err(_) => {}
                        };
                    }
                    AuthLoginType::Delegation(evnt) => {
                        self.add_field(
                            field_dictionary::USER_NAME,
                            SiemField::User(evnt.destination_user.to_string()),
                        );
                        self.add_field(
                            "source.user.name",
                            SiemField::User(evnt.source_user.to_string()),
                        );
                        self.add_field(
                            field_dictionary::USER_DOMAIN,
                            SiemField::Domain(evnt.destination_domain.to_string()),
                        );
                        self.add_field(
                            "source.user.domain",
                            SiemField::Domain(evnt.source_domain.to_string()),
                        );
                    }
                };
            }
            SiemEvent::DHCP(dhcp) => {
                self.add_field(
                    "host.hostname",
                    SiemField::Text(LogString::Owned(dhcp.hostname().to_string())),
                );
                self.add_field(
                    "server.hostname",
                    SiemField::Text(LogString::Owned(dhcp.hostname().to_string())),
                );
                self.add_field(
                    "client.hostname",
                    SiemField::Text(LogString::Owned(dhcp.source_hostname().to_string())),
                );
                self.add_field("client.ip", SiemField::IP(dhcp.source_ip().clone()));
                self.add_field(
                    "client.mac",
                    SiemField::from_str(dhcp.source_mac().to_string()),
                );
                self.add_field(
                    field_dictionary::DHCP_RECORD_TYPE,
                    SiemField::from_str(dhcp.record_type().to_string()),
                );
                match dhcp.record_type() {
                    DhcpRecordType::Assign => {}
                    DhcpRecordType::Release => {}
                    DhcpRecordType::Request => {
                        self.add_field(
                            "dhcp.requested_ip",
                            SiemField::IP(dhcp.source_ip().clone()),
                        );
                    }
                };
            }
            _ => {}
        }
        self.event = event;
    }
    pub fn fields(&self) -> EventIter<'_> {
        EventIter {
            children: self.fields.iter(),
        }
    }
    pub fn iter(&self) -> EventIter<'_> {
        EventIter {
            children: self.fields.iter(),
        }
    }
    pub fn iter_mut(&mut self) -> EventIterMut<'_> {
        EventIterMut {
            children: self.fields.iter_mut(),
        }
    }
    pub fn ip_fields(&self) -> EventFieldIter<'_> {
        EventFieldIter {
            names: self.ip_fields.iter(),
            fields: &self.fields,
        }
    }
}

pub struct EventIter<'a> {
    children: std::collections::btree_map::Iter<'a, LogString, SiemField>,
}
pub struct EventFieldIter<'a> {
    names: std::collections::btree_set::Iter<'a, LogString>,
    fields: &'a BTreeMap<LogString, SiemField>,
}

pub struct EventIterMut<'a> {
    children: std::collections::btree_map::IterMut<'a, LogString, SiemField>,
}

impl<'a> Iterator for EventIter<'a> {
    type Item = (&'a LogString, &'a SiemField);

    fn next(&mut self) -> Option<Self::Item> {
        self.children.next()
    }
}
impl<'a> Iterator for EventIterMut<'a> {
    type Item = (&'a LogString, &'a mut SiemField);

    fn next(&mut self) -> Option<Self::Item> {
        self.children.next()
    }
}
impl<'a> Iterator for EventFieldIter<'a> {
    type Item = (&'a LogString, &'a SiemField);

    fn next(&mut self) -> Option<Self::Item> {
        let field = self.names.next()?;
        let value = self.fields.get(field)?;
        Some((field, value))
    }
}

#[cfg(test)]
mod tests {
    use super::firewall::FirewallOutcome;
    use super::protocol::NetworkProtocol;
    use super::*;

    #[test]
    fn check_log() {
        let mut log = SiemLog::new("<134>Aug 23 20:30:25 OPNsense.localdomain filterlog[21853]: 82,,,0,igb0,match,pass,out,4,0x0,,62,25678,0,DF,17,udp,60,192.168.1.8,8.8.8.8,5074,53,40", 0, "localhost");
        log.set_event(SiemEvent::Firewall(FirewallEvent {
            source_ip: SiemIp::V4(0),
            destination_ip: SiemIp::V4(10000),
            source_port: 10000,
            destination_port: 443,
            outcome: FirewallOutcome::ALLOW,
            in_bytes: 0,
            out_bytes: 0,
            in_interface: LogString::Borrowed("in123"),
            out_interface: LogString::Borrowed("out123"),
            network_protocol: NetworkProtocol::TCP,
        }));
        log.add_field(
            "event.dataset",
            SiemField::Text(LogString::Borrowed("filterlog")),
        );
        match log.field("event.dataset") {
            Some(val) => match val {
                SiemField::Text(val) => {
                    assert_eq!(val, "filterlog")
                }
                _ => assert_eq!(1, 2),
            },
            _ => assert_eq!(1, 2),
        };
    }
}
